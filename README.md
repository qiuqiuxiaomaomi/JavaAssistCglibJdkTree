# JavaAssistCglibJdkTree
jdk,JavaAssist,Cglib动态代理技术研究


![](https://i.imgur.com/A52Ya8P.png)

<pre>
代理：
        代理是一种常用的设计模式，其目的就是为其它对象提供一个代理以控制对某个对象的访问。
     代理类负责为委托类预处理消息，过滤消息并转发消息。

        为了保持行为的一致性，代理类和委托类通常会实现相同的接口。通过代理类这中间这一层，能
     有效控制对委托类对象的直接访问，可以很好的隐藏和保护委托类对象，同时也为实施不同控制
     策略预留了空间，从而在设计上获得更大的灵活性。
</pre>

<pre>
静态代理：
     在编译期确定代理对象；

     缺点：
         1）代理类和委托类实现了相同的接口，代理类通过委托类实现了相同的方法。这样就出现了
            大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代
            理类也需要定义这个接口，增加了代码维护的复杂性。
         2）代理对象只服务于一种类型的对象，如果要服务于多类型的对象。势必要为每一种对象都
            进行代理，静态代理在程序程序规模稍大时就无法胜任了。
</pre>


动态代理中万能的代理类

![](https://i.imgur.com/ZfhvGQc.png)

<pre>
动态代理：
     在运行时才能确定代理对象；

     动态代理和静态代理相比，最大的好处就是接口中申明的所有方法都被转移到一个集中的方法中处
  理，就是invoke()方法，这样在接口中声明的方法比较多的情况下我们可以进行灵活处理。

     动态代理只能代理接口，代理类都需要实现 InvocationHandler类，实现invoke方法，该
  方法是调用被代理接口的所有方法时需要调用的，该invoke方法的返回值是被代理接口的一个实现类。
</pre>


![](https://i.imgur.com/C95PPlx.png)

<pre>
区别：
      JDK动态代理：
          只能对实现了接口的类实行代理，而不针对类。
      CGLIB：
          是针对类实现代理。
          使用字节码技术，不能对 final类进行继承。使用了动态生成字节码技术
</pre>